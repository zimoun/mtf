#!/usr/bin/env python

# This script calculates the field generated by a z-polarised, x-propagating
# plane wave incident on a dielectric sphere.

# Help Python find the bempp module
import sys
sys.path.append("..")

from bempp.lib import *
import numpy as np

from matplotlib import pylab as pl

import scipy.linalg as la
import scipy.sparse as sp
import scipy.sparse.linalg as spla

import time

from tools import createList

# Physical Parameters

kExt = 0.1
N = 4

meshname = 'sphere-disjoint.msh'

# eps = [1, 2, 3]

surfs = [ i+1 for i in range(N) ]

doms = [
    { 'name': '0',
      'eps': 1,
      'union': [-surfs[i] for i in range(len(surfs))],
      'neighbor': ['A', 'B', 'C', 'D']
      },
    { 'name': 'A',
      'eps': 2,
      'union': surfs[0],
      'neighbor': '0'
      },
    { 'name': 'B',
      'eps': 2,
      'union': surfs[1],
      'neighbor': '0'
      },
    { 'name': 'C',
    'eps': 2,
    'union': surfs[2],
      'neighbor': '0'
    },
    { 'name': 'D',
      'eps': 2,
      'union': surfs[3],
      'neighbor': '0'
  }
]

Shape = 0
for dom in doms:
    try:
        Shape += len(dom['union'])
    except:
        dom['union'] = [dom['union']]
        Shape += 1
Shape = (2*Shape, 2*Shape)


# Boundary conditions

def evalIncDirichletTrace(point, normal):
    x, y, z = point
    return -np.exp( 1j * kExt * (x))

def evalIncNeumannTrace(point, normal):
    x, y, z = point
    nx, ny, nz = normal
#    return -1j * (nx+ny) * kExt * np.exp( 1j * kExt * (x+y))
#    return 1j * nx * kExt * np.exp( 1j * kExt * x)
    return -1j * nx * kExt * np.exp( 1j * kExt * x)

#
print('==== Load mesh')
grid = createGridFactory().importGmshGrid(
    "triangular", meshname)

interfaces = {}
for ii in surfs:
    interfaces[ii] = (GridSegment.closedDomain(grid, ii))

#
print('==== Create quadrature strategy')

accuracyOptions = createAccuracyOptions()
accuracyOptions.doubleRegular.setRelativeQuadratureOrder(2)
accuracyOptions.doubleSingular.setRelativeQuadratureOrder(1)
quadStrategy = createNumericalQuadratureStrategy(
    "float64", "complex128", accuracyOptions)

#
print('==== Create assembly context')

assemblyOptions = createAssemblyOptions()
#assemblyOptions.switchToAcaMode(createAcaOptions())
context = createContext(quadStrategy, assemblyOptions)

#
print('==== Initialize functional spaces')

FullSpace = createPiecewiseLinearContinuousScalarSpace(context, grid)

spaces = {}
for ii, interface in interfaces.items():
    Vi = createPiecewiseLinearContinuousScalarSpace(context, grid, interface,
                                                    strictlyOnSegment=True)
    spaces[ii] = Vi


Context = (context, spaces, doms)

#
print('==== Define the grid functions for the traces of incident field')

incDirichletTraces = {}
incNeumannTraces = {}
for ii, Vi in spaces.items():
    rhsD = createGridFunction(
        context, Vi, Vi, evalIncDirichletTrace,
        surfaceNormalDependent=True)
    rhsN = createGridFunction(
        context, Vi, Vi, evalIncNeumannTrace,
        surfaceNormalDependent=True)

    incDirichletTraces[ii] = rhsD
    incNeumannTraces[ii] = rhsN

# Extract plane wave

# exportToGmsh(incDirichletTraceA, 'inc-dext', 'Inc_D_A.pos')
# exportToGmsh(incDirichletTraceB, 'inc-dext', 'Inc_D_B.pos')


print('==== Construct elementary operators')

#####################################
#####################################
MyDiag_symbol, MyDiag = createList(Context, Shape)

MyId_symbol, MyId = createList(Context, Shape)

row, col = 0, 0
for r, dom in enumerate(doms):
    myname = dom['name']
    k = dom['eps'] * kExt
    ni = len(dom['union'])
    for my in dom['union']:
        itest = np.abs(my)
        test = spaces[itest]

        for c, other in enumerate(dom['union']):
            itrial = np.abs(other)
            trial = spaces[itrial]

            for offset, kind in enumerate(['D', 'N']):

                si = 'I_' + myname + '_{}{}'.format(itest, itrial)
                Id = createIdentityOperator(
                    context, trial, trial, test, si)

                if kind == 'D':
                    sk = 'K_' + myname + '_{}{}'.format(itest, itrial)
                    K = createHelmholtz3dDoubleLayerBoundaryOperator(
                        context, trial, trial, test, k, sk)
                    sv = 'V_' + myname + '_{}{}'.format(itest, itrial)
                    V = createHelmholtz3dSingleLayerBoundaryOperator(
                        context, trial, trial, test, k, sv)
                    K = np.sign(my) * K

                    MyId_symbol[row][c+col] = si
                    MyId[row][c+col] = Id

                    # print(row, c+col, sk, sv)
                    MyDiag_symbol[row][c+col] = '-'+sk
                    MyDiag_symbol[row][c+col+ni] = sv
                    MyDiag[row][c+col] = - 2*K
                    MyDiag[row][c+col+ni] = 2*V


                if kind == 'N':
                    sw = 'W_' + myname + '_{}{}'.format(itest, itrial)
                    W = createHelmholtz3dHypersingularBoundaryOperator(
                        context, trial, trial, test, k, sw)
                    sq = 'Q_' + myname + '_{}{}'.format(itest, itrial)
                    Q = createHelmholtz3dAdjointDoubleLayerBoundaryOperator(
                        context, trial, trial, test, k, sq)
                    Q = np.sign(other) * Q
                    W = np.sign(my)*np.sign(other) * W

                    MyId_symbol[row+ni][c+col+ni] = si
                    MyId[row+ni][c+col+ni] = Id

                    # print(row+ni, c+col, sw, sq)
                    MyDiag_symbol[row+ni][c+col] = sw
                    MyDiag_symbol[row+ni][c+col+ni] = sq
                    MyDiag[row+ni][c+col] = 2*W
                    MyDiag[row+ni][c+col+ni] = 2*Q


        row += 1
    row +=  ni
    col +=  2*ni


#####################################
#####################################
MyCouple_symbol, MyCouple = createList(Context, Shape)

for pos, dom in enumerate(doms):
    myname = dom['name']
    neighborhood = dom['neighbor']
    ni = len(dom['union'])
    # print('')
    # print('\tdomain: '+myname)
    for neighbor in neighborhood:
        r = 0
        # print('neighbor: '+neighbor)
        c = 0
        for d in doms[0:pos]:
            r += 2*len(d['union'])
        for odom in doms:
            if odom['name'] == neighbor:
                break
            c += 2*len(odom['union'])
        Ni = len(odom['union'])
        for other in odom['union']:
            itrial = np.abs(other)
            trial = spaces[itrial]
            for my in dom['union']:
                found = False
                itest = np.abs(my)
                test = spaces[itest]
                if itrial == itest:
                    found = True
                    break
                if Ni > 1:
                    c += 1
                elif ni > 1:
                    r += 1
                else:
                    raise('Common Interfaces ?')


            if found:
                #print(r, c, r+ni, c+Ni)
                si = 'I_' + myname+odom['name'] + '_{}{}'.format(itest, itrial)
                Id = createIdentityOperator(
                    context, trial, trial, test, si)

                MyCouple_symbol[r][c] = si
                MyCouple_symbol[r+ni][c+Ni] = '-'+si
                MyCouple[r][c] = Id
                MyCouple[r+ni][c+Ni] = -Id




#####################################
#####################################

opA = createBlockedBoundaryOperator(
    context, MyDiag)
opId = createBlockedBoundaryOperator(
    context, MyId)
opX = createBlockedBoundaryOperator(
    context, MyCouple)

wId = opId.weakForm()

wX = opX.weakForm()

wA = opA.weakForm()

Id = wId.asMatrix()
X = wX.asMatrix()
A = wA.asMatrix()


#
#####################################
#####################################

sys.exit('yep')

rhsMTF = [
    0.5* incDirichletTraceA,
    0.5* incDirichletTraceB,
    -0.5* incNeumannTraceA,
    -0.5* incNeumannTraceB,
    -0.5* incDirichletTraceA,
    -0.5* incNeumannTraceA,
    -0.5* incDirichletTraceB,
    -0.5* incNeumannTraceB
]



for os in MTF_list:
    for o in os:
        a = o.weakForm()
for o in rhsMTF:
    a = o.projections()

#
print('==== Initialize the solver')

# MTFsolver = createDefaultDirectSolver(MTF)

MTFsolver = createDefaultIterativeSolver(MTF)
MTFsolver.initializeSolver(defaultGmresParameterList(1e-8))

#
print('==== Solve MTF \t'),
print(MTF.weakForm().shape)
sys.stdout.flush()

t0 = time.time()
MTFsolution = MTFsolver.solve(rhsMTF)
t1 = time.time()
print(t1-t0)
print(MTFsolution.solverMessage())
print(MTFsolution.iterationCount())


print('==== end solved... extraction...')

########################################################
########################################################

# MTF extraction
# Extract the solution components in the form of grid functions

MTFextDirichletTraceA = MTFsolution.gridFunction(0)
MTFextDirichletTraceB = MTFsolution.gridFunction(1)
MTFextNeumannTraceA = MTFsolution.gridFunction(2)
MTFextNeumannTraceB = MTFsolution.gridFunction(3)

# exportToGmsh(MTFextDirichletTrace, 'MTF-dext', 'MTF_Dext.pos')
# exportToGmsh(MTFextNeumannTrace, 'MTF-next', 'MTF_Next.pos')

# MTFscattDirichletTrace = MTFextDirichletTrace - incDirichletTrace
# MTFscattNeumannTrace = MTFextNeumannTrace + incNeumannTrace

# exportToGmsh(MTFscattDirichletTrace, 'MTF-dsca', 'MTF_Dsca.pos')
# exportToGmsh(-MTFscattNeumannTrace, 'MTF-nsca', 'MTF_Nsca.pos')

# imagMTFscattDirichletTrace = - 1j * MTFscattDirichletTrace
# exportToGmsh(imagMTFscattDirichletTrace, 'MTF-dsca-i', 'MTF_DscaI.pos')
# exportToGmsh(MTFscattDirichletTrace, 'MTF-dsca-r', 'MTF_DscaR.pos')

MTFintDirichletTraceA = MTFsolution.gridFunction(4)
MTFintNeumannTraceA = MTFsolution.gridFunction(5)

MTFintDirichletTraceB = MTFsolution.gridFunction(6)
MTFintNeumannTraceB = MTFsolution.gridFunction(7)


# exportToGmsh(MTFintDirichletTrace, 'MTF-dint', 'MTF_Dint.pos')
# exportToGmsh(MTFintNeumannTrace, 'MTF-nint', 'MTF_Nint.pos')

# exportToGmsh(-0.5j*MTFintNeumannTrace, 'MTF-nint2', 'MTF_Nint2.pos')

# #
# MTFextDirichletTraceMass = Id *MTFsolution.gridFunction(0)
# MTFextNeumannTraceMass = Id * MTFsolution.gridFunction(1)

# exportToGmsh(MTFextDirichletTraceMass, 'MTF-dextM', 'MTF_Dmext.pos')
# exportToGmsh(MTFextNeumannTraceMass, 'MTF-nextM', 'MTF_Nmext.pos')

# MTFintDirichletTraceMass = Id * MTFsolution.gridFunction(2)
# MTFintNeumannTraceMass = Id * MTFsolution.gridFunction(3)

# exportToGmsh(MTFintDirichletTraceMass, 'MTF-dintM', 'MTF_Dmint.pos')
# exportToGmsh(MTFintNeumannTraceMass, 'MTF-nintM', 'MTF_Nmint.pos')

t =  MTFextDirichletTraceA
exportToGmsh(t, 'MTF-dext-r', 'MTF_DextR-A.pos')
tI = -1j * t
exportToGmsh(tI, 'MTF-dext-i', 'MTF_DextI-A.pos')

t =  MTFintDirichletTraceA
exportToGmsh(t, 'MTF-dint-r', 'MTF_DintR-A.pos')
tI = -1j * t
exportToGmsh(tI, 'MTF-dint-i', 'MTF_DintI-A.pos')

t =  MTFintDirichletTraceB
exportToGmsh(t, 'MTF-dint-r', 'MTF_DintR-B.pos')
tI = -1j * t
exportToGmsh(tI, 'MTF-dint-i', 'MTF_DintI-B.pos')


# t =  MTFscattDirichletTrace
# exportToGmsh(t, 'MTF-dsca-r', 'MTF_DscaR.pos')
# tI = -1j * t
# exportToGmsh(tI, 'MTF-dsca-i', 'MTF_DscaI.pos')

# t =  MTFscattNeumannTrace
# exportToGmsh(t, 'MTF-nsca-r', 'MTF_NscaR.pos')
# tI = -1j * t
# exportToGmsh(tI, 'MTF-nsca-i', 'MTF_NscaI.pos')

########################################################
########################################################

print('\n post\n')

normDextA = MTFextDirichletTraceA.L2Norm()
normDextB = MTFextDirichletTraceB.L2Norm()
normNextA = MTFextNeumannTraceA.L2Norm()
normNextB = MTFextNeumannTraceB.L2Norm()
normDintA = MTFintDirichletTraceA.L2Norm()
normDintB = MTFintDirichletTraceB.L2Norm()
normNintA = MTFintNeumannTraceA.L2Norm()
normNintB = MTFintNeumannTraceB.L2Norm()

normDincA = incDirichletTraceA.L2Norm()
normNincA = incNeumannTraceA.L2Norm()

normDincB = incDirichletTraceB.L2Norm()
normNincB = incNeumannTraceB.L2Norm()


jDA = (MTFextDirichletTraceA - MTFintDirichletTraceA -incDirichletTraceA).L2Norm()
jNA = (-MTFextNeumannTraceA - MTFintNeumannTraceA -incNeumannTraceA).L2Norm()

jDB = (MTFextDirichletTraceB - MTFintDirichletTraceB -incDirichletTraceB).L2Norm()
jNB = (-MTFextNeumannTraceB - MTFintNeumannTraceB -incNeumannTraceB).L2Norm()


print('')
print('# L^2')
# print("# norm  {:^15} {:^15} {:^15} {:^15} {:^15} {:^15}".format(
#     'DextA', 'DintA',
#     'DincA',
#     'NextA', 'NintA',
#     'NincA'
# ))
print("# norm  {:^15} {:^15} {:^15} {:^15} {:^15} {:^15}".format(
    'DextA/B', 'DintA/B',
    'DincA/B',
    'NextA/B', 'NintA/B',
    'NincA/B'
))
print("# MTF   {:^15E} {:^15E} {:^15E} {:^15E} {:^15E} {:^15E}".format(
    normDextA, normDintA,
    normDincA,
    normNextA, normNintA,
    normNincA
))
#
# print("# norm  {:^15} {:^15} {:^15} {:^15} {:^15} {:^15}".format(
#     'DextB', 'DintB',
#     'DincB',
#     'NextB', 'NintB',
#     'NincB'
# ))
print("# MTF   {:^15E} {:^15E} {:^15E} {:^15E} {:^15E} {:^15E}".format(
    normDextB, normDintB,
    normDincB,
    normNextB, normNintB,
    normNincB
))
##
print('')
print("# error  {:^15} {:^15} {:^15} {:^15}".format(
    'jumpDA', 'jumpNA',
    'jumpDB', 'jumpNB'
    ))
print("# MTF    {:^15E} {:^15E} {:^15E} {:^15E}".format(
    jDA, jNA, jDB, jNB
))
print('')


sys.exit('bye.')

M = MTF.weakForm().asMatrix()

pdA = incDirichletTraceA.projections()
pdB = incDirichletTraceB.projections()
pnA = incNeumannTraceA.projections()
pnB = incNeumannTraceB.projections()

cdA = incDirichletTraceA.coefficients()
cdB = incDirichletTraceB.coefficients()
cnA = incNeumannTraceA.coefficients()
cnB = incNeumannTraceB.coefficients()

v = np.array([], dtype=complex)
v = np.concatenate((v, 0*cdA))
v = np.concatenate((v, 0*cdB))
v = np.concatenate((v, 0*cnA))
v = np.concatenate((v, 0*cnB))

v = np.concatenate((v, -cdA))
v = np.concatenate((v, -cnA))
v = np.concatenate((v, -cdB))
v = np.concatenate((v, -cnB))

b = M.dot(v)

beg, end = 0, len(pdA)
ppdA, beg, end = 2.0 * b[beg:end], end, end+len(pdB)
ppdB, beg, end = 2.0 * b[beg:end], end, end+len(pnA)
ppnA, beg, end = -2.0 * b[beg:end], end, end+len(pnB)
ppnB, beg, end = -2.0 * b[beg:end], end, end+len(pnB)

ppdA_1, beg, end = -2.0 * b[beg:end], end, end+len(pdA)
ppnA_1, beg, end = -2.0 * b[beg:end], end, end+len(pnA)

ppdB_2, beg, end = -2.0 * b[beg:end], end, end+len(pdB)
ppnB_2, beg, end = -2.0 * b[beg:end], end, end+len(pnB)
