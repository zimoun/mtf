#!/usr/bin/env python

# This script calculates the field generated by a z-polarised, x-propagating
# plane wave incident on a dielectric sphere.

# Help Python find the bempp module
import sys
sys.path.append("..")

from bempp.lib import *
import numpy as np

from matplotlib import pylab as pl

import scipy.linalg as la
import scipy.sparse as sp
import scipy.sparse.linalg as spla

from scipy.io import savemat

import time

# Physical Parameters

k = 5

RegQuad = 2
SinQuad = 1

#
print('==== Create quadrature strategy')

accuracyOptions = createAccuracyOptions()
accuracyOptions.doubleRegular.setRelativeQuadratureOrder(RegQuad)
accuracyOptions.doubleSingular.setRelativeQuadratureOrder(SinQuad)
quadStrategy = createNumericalQuadratureStrategy(
    "float64", "complex128", accuracyOptions)

#
print('==== Create assembly context')

assemblyOptions = createAssemblyOptions()
#assemblyOptions.switchToAcaMode(createAcaOptions())
context = createContext(quadStrategy, assemblyOptions)

#
print('==== Load mesh')
#meshname = "./sphere-simple.msh"
#meshname = "./sphere.msh"
#meshname = "./cube.msh"
#meshname = "./cylinder-simple.msh"
#meshname = "./sphere-sphere.msh"
meshname = "./ellipse-concentric.msh"
grid = createGridFactory().importGmshGrid(
    "triangular", meshname)

#
print('==== Initialize functional spaces')

#space = createPiecewiseConstantScalarSpace(context, grid)
#space = createPiecewiseConstantDualGridScalarSpace(context, grid)

space = createPiecewiseLinearContinuousScalarSpace(context, grid)

#space = createPiecewisePolynomialContinuousScalarSpace(context, grid,
                                                       # polynomialOrder=1)
#space = createPiecewiseLinearDiscontinuousScalarSpace(context, grid)



print('==== Construct elementary operators')


V = createHelmholtz3dSingleLayerBoundaryOperator(
    context, space, space, space, k, "V")
K = createHelmholtz3dDoubleLayerBoundaryOperator(
    context, space, space, space, k, "K")
Q = createHelmholtz3dAdjointDoubleLayerBoundaryOperator(
    context, space, space, space, k, "Q")
W = createHelmholtz3dHypersingularBoundaryOperator(
    context, space, space, space, k, "W")

Id = createIdentityOperator(
    context, space, space, space, "Id")
Zd = createNullOperator(
    context, space, space, space, "Zd")

# # reorientation normal
# ak, bq = -1. , -1.
# K0, K0a = ak * K0, bq * K0a

#

A_list = [
    [ -K, V ],
    [W, Q]
]
oA = createBlockedBoundaryOperator(
    context, A_list)

J_list = [
    [ Id, Zd ],
    [Zd, Id]
]
oJ = createBlockedBoundaryOperator(
    context, J_list)

print('==== Assemble A')
A = oA.weakForm().asMatrix()
sys.stdout.flush()

print('==== Assemble J')
sys.stdout.flush()
J = oJ.weakForm().asMatrix()


print('==== Save to Matlab')
print(A.shape)
sys.stdout.flush()

string = '{}'.format(k)
sk = ''
for s in string:
    if s == '.':
        s = '_'
    sk = sk + s
toMLab = {'A_'+sk : A, 'J_'+sk : J}
name = 'fromBempp_'+sk+'.mat'
savemat(name, toMLab)
