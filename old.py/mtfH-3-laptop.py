#!/usr/bin/env python

# This script calculates the field generated by a z-polarised, x-propagating
# plane wave incident on a dielectric sphere.

# Help Python find the bempp module
import sys
sys.path.append("..")

from bempp.lib import *
import numpy as np

from matplotlib import pylab as pl

import scipy.linalg as la
import scipy.sparse as sp
import scipy.sparse.linalg as spla

import time

# Physical Parameters

epsInt = 1.5**2
epsExt = 1
muInt = 1
muExt = 1
wavelengthVacuum = 24.
kVacuum = 2 * np.pi / wavelengthVacuum
kExt = kVacuum * np.sqrt(epsExt * muExt)
kInt = kVacuum * np.sqrt(epsInt * muInt)
rho = (kInt * muExt) / (kExt * muInt)

# Boundary conditions

def evalIncDirichletTrace(point, normal):
    x, y, z = point
    return np.exp( 1j * kExt * (x+y))

def evalIncNeumannTrace(point, normal):
    x, y, z = point
    nx, ny, nz = normal
    return 1j * (nx+ny) * kExt * np.exp( 1j * kExt * (x+y))


# 
print('==== Create quadrature strategy')

accuracyOptions = createAccuracyOptions()
accuracyOptions.doubleRegular.setRelativeQuadratureOrder(2)
accuracyOptions.doubleSingular.setRelativeQuadratureOrder(1)
quadStrategy = createNumericalQuadratureStrategy(
    "float64", "complex128", accuracyOptions)

# 
print('==== Create assembly context')

assemblyOptions = createAssemblyOptions()
#assemblyOptions.switchToAcaMode(createAcaOptions())
context = createContext(quadStrategy, assemblyOptions)

# 
print('==== Load mesh')
meshname = "./sphere-simple.msh"
#meshname = "./sphere.msh"
#meshname = "./cube.msh"
grid = createGridFactory().importGmshGrid(
    "triangular", meshname)

# 
print('==== Initialize functional spaces')

#space = createPiecewiseConstantScalarSpace(context, grid)
#space = createPiecewiseConstantDualGridScalarSpace(context, grid)

space = createPiecewiseLinearContinuousScalarSpace(context, grid)

#space = createPiecewisePolynomialContinuousScalarSpace(context, grid, 
                                                       # polynomialOrder=1)
#space = createPiecewiseLinearDiscontinuousScalarSpace(context, grid)

# 
print('==== Define the grid functions for the traces of incident field')

incDirichletTrace = createGridFunction(
    context, space, space, evalIncDirichletTrace,
    surfaceNormalDependent=True)
incNeumannTrace = createGridFunction(
    context, space, space, evalIncNeumannTrace,
    surfaceNormalDependent=True)

#
print('==== Construct elementary operators')


V0 = createHelmholtz3dSingleLayerBoundaryOperator(
    context, space, space, space, kExt, "V")
K0 = createHelmholtz3dDoubleLayerBoundaryOperator(
    context, space, space, space, kExt, "K")
K0a = createHelmholtz3dAdjointDoubleLayerBoundaryOperator(
    context, space, space, space, kExt, "K")
W0 = createHelmholtz3dHypersingularBoundaryOperator(
    context, space, space, space, kExt, "W")
V1 = createHelmholtz3dSingleLayerBoundaryOperator(
    context, space, space, space, kInt, "V1")
K1 = createHelmholtz3dDoubleLayerBoundaryOperator(
    context, space, space, space, kInt, "K1")
K1a = createHelmholtz3dAdjointDoubleLayerBoundaryOperator(
    context, space, space, space, kInt, "K1")
W1 = createHelmholtz3dHypersingularBoundaryOperator(
    context, space, space, space, kInt, "W1")

Id = createIdentityOperator(
    context, space, space, space, "Id")
Zd = createNullOperator(
    context, space, space, space, "Zd")

# reorientation normal
ak, bq = -1. , -1.
K0, K0a = ak * K0, bq * K0a

# 
print('==== Form the STF matrix')

STF00 = -K0+K1
STF01 = V0+V1
STF10 = W0+W1
STF11 = K0a-K1a

STF_list = [[STF00, STF01], [STF10, STF11]]

STF = createBlockedBoundaryOperator(
    context, STF_list)

for obj in STF_list:
    for o in obj:
        a = o.weakForm()
a = Id.weakForm()

rhsP = [Id * incNeumannTrace, Id * incDirichletTrace]
rhsSTF = [ (0.5*Id + K1) * incDirichletTrace - V1 * incNeumannTrace,
           +W1 * incDirichletTrace + (-0.5*Id+K1a) * incNeumannTrace]


# 
print('==== Form the MTF matrix')

Half= -0.5 * Id
ZZ =  Zd

MTF_list = [ 
    [-K0, V0, Half, ZZ], 
    [W0, K0a, ZZ, -Half],
    [Half, ZZ, -K1, V1], 
    [ZZ, -Half, W1, K1a] 
    ]

MTF = createBlockedBoundaryOperator(
    context, MTF_list)

rhsMTF = [0.5*Id * incDirichletTrace,
          -0.5*Id * incNeumannTrace, 
          -0.5*Id * incDirichletTrace,
          -0.5*Id * incNeumannTrace]

rhsMTF_wo = [0.5 * incDirichletTrace,
          -0.5 * incNeumannTrace, 
          -0.5 * incDirichletTrace,
          -0.5 * incNeumannTrace]


for os in MTF_list:
    for o in os:
        a = o.weakForm()
for o in rhsMTF:
    a = o.projections()

# 
print('==== Initialize the solver')

STFsolver = createDefaultDirectSolver(STF)
MTFsolver = createDefaultDirectSolver(MTF)

# 
print('==== Solve STF')

STFsolution = STFsolver.solve(rhsSTF)
print STFsolution.solverMessage()

print('==== Solve MTF')
t0 = time.time()
MTFsolution = MTFsolver.solve(rhsMTF)
t1 = time.time()
print(t1-t0)
print MTFsolution.solverMessage()

print('==== end solved... extraction...')

########################################################
########################################################

# STF extraction
# Extract the solution components in the form of grid functions

STFextDirichletTrace = STFsolution.gridFunction(0)
STFextNeumannTrace = STFsolution.gridFunction(1)

exportToGmsh(STFextDirichletTrace, 'STF-dext', 'STF_Dext.pos')
exportToGmsh(STFextNeumannTrace, 'STF-next', 'STF_Next.pos')

STFscattDirichletTrace = STFextDirichletTrace - incDirichletTrace
STFscattNeumannTrace = STFextNeumannTrace - incNeumannTrace

exportToGmsh(STFscattDirichletTrace, 'STF-dsca', 'STF_Dsca.pos')

STFintDirichletTrace = STFextDirichletTrace
STFintNeumannTrace = STFextNeumannTrace 

########################################################
########################################################

# MTF extraction
# Extract the solution components in the form of grid functions

MTFextDirichletTrace = MTFsolution.gridFunction(0)
MTFextNeumannTrace = MTFsolution.gridFunction(1)

exportToGmsh(MTFextDirichletTrace, 'MTF-dext', 'MTF_Dext.pos')
exportToGmsh(MTFextNeumannTrace, 'MTF-next', 'MTF_Next.pos')

MTFscattDirichletTrace = MTFextDirichletTrace - incDirichletTrace
MTFscattNeumannTrace = MTFextNeumannTrace + incNeumannTrace

exportToGmsh(MTFscattDirichletTrace, 'MTF-dsca', 'MTF_Dsca.pos')
exportToGmsh(-MTFscattNeumannTrace, 'MTF-nsca', 'MTF_Nsca.pos')

MTFintDirichletTrace = MTFsolution.gridFunction(2)
MTFintNeumannTrace = MTFsolution.gridFunction(3)

exportToGmsh(MTFintDirichletTrace, 'MTF-dint', 'MTF_Dint.pos')
exportToGmsh(MTFintNeumannTrace, 'MTF-nint', 'MTF_Nint.pos')

exportToGmsh(-0.5j*MTFintNeumannTrace, 'MTF-nint2', 'MTF_Nint2.pos')

# #
# MTFextDirichletTraceMass = Id *MTFsolution.gridFunction(0)
# MTFextNeumannTraceMass = Id * MTFsolution.gridFunction(1)

# exportToGmsh(MTFextDirichletTraceMass, 'MTF-dextM', 'MTF_Dmext.pos')
# exportToGmsh(MTFextNeumannTraceMass, 'MTF-nextM', 'MTF_Nmext.pos')

MTFintDirichletTraceMass = Id * MTFsolution.gridFunction(2)
MTFintNeumannTraceMass = Id * MTFsolution.gridFunction(3)

exportToGmsh(MTFintDirichletTraceMass, 'MTF-dintM', 'MTF_Dmint.pos')
exportToGmsh(MTFintNeumannTraceMass, 'MTF-nintM', 'MTF_Nmint.pos')

########################################################
########################################################

print('\n post\n')

Half= 0.0 * Id
ZZ =  Zd

a = [ 
    [-K0, V0, Half, ZZ], 
    [W0, K0a, ZZ, -Half],
    [Half, ZZ, -K1, V1], 
    [ZZ, -Half, W1, K1a] 
    ]
t = time.time()
AAblock = createBlockedBoundaryOperator(context, a)
tt = time.time()
print(tt-t)
t = time.time()
a = [ 
    [-K0, V0], 
    [W0, K0a]
    ]
A0block = createBlockedBoundaryOperator(context, a)
tt = time.time()
print(tt-t)
t = time.time()
a = [
    [-K1, V1], 
    [W1, K1a]
    ]
A1block = createBlockedBoundaryOperator(context, a)
tt = time.time()
print(tt-t)
t = time.time()
Ismallblock = createBlockedBoundaryOperator(
    context, 
    [ [Id, Zd], 
      [Zd, Id] ]
    )
tt = time.time()
print(tt-t)
t = time.time()
IIblock = createBlockedBoundaryOperator(
    context, 
    [ [Id, ZZ, Half, ZZ], 
      [ZZ, Id, ZZ, Half],
      [Half, ZZ, Id, ZZ], 
      [ZZ, Half, ZZ, Id] ]
    )
tt = time.time()
print(tt-t)
t = time.time()
print('building M...'),
sys.stdout.flush()
M = MTF.weakForm().asMatrix()
tt = time.time()
print(tt-t),

print('building b...'),
sys.stdout.flush()

b = np.array([])
for v in rhsMTF:
    b = np.concatenate((b, v.projections()))
tt = time.time()
print(tt-t),
print('done.\n')

print('solve MTF with Numpy... be patient [take time]'),
print(M.shape)
t0 = time.time()
x = np.linalg.solve(M, b)
t1 = time.time()
print(t1-t0)

t = time.time()
print('building A...'),
sys.stdout.flush()
A = AAblock.weakForm().asMatrix()
tt = time.time()
print(tt-t),
t = time.time()
print('building II...'),
sys.stdout.flush()
II = IIblock.weakForm().asMatrix()
tt = time.time()
print(tt-t),
t = time.time()

A0 = A0block.weakForm().asMatrix()
A1 = A1block.weakForm().asMatrix()
IJ = Ismallblock.weakForm().asMatrix()

bb = np.array([])
for v in rhsMTF_wo:
    bb = np.concatenate((bb, v.projections()))
tt = time.time()
# print(tt-t),

print('done.\n')


y = np.array([])
for ii in xrange(len(rhsMTF)):
    gf = MTFsolution.gridFunction(ii)
    y = np.concatenate((y, gf.coefficients()))

yy = np.array([])
for ii in xrange(len(rhsSTF)):
    gf = STFsolution.gridFunction(ii)
    yy = np.concatenate((yy, gf.coefficients()))
for ii in xrange(len(rhsSTF)):
    gf = STFsolution.gridFunction(ii)
    yy = np.concatenate((yy, gf.coefficients()))

yext = np.array([])
yext = np.concatenate((yext, MTFsolution.gridFunction(0).coefficients()))
yext = np.concatenate((yext, MTFsolution.gridFunction(1).coefficients()))

yint = np.array([])
yint = np.concatenate((yint, MTFsolution.gridFunction(2).coefficients()))
yint = np.concatenate((yint, MTFsolution.gridFunction(3).coefficients()))

yint_sign = np.array([])
yint_sign = np.concatenate((yint_sign, MTFsolution.gridFunction(2).coefficients()))
yint_sign = np.concatenate((yint_sign, -MTFsolution.gridFunction(3).coefficients()))


ysca = np.array([])
ysca = np.concatenate((ysca, MTFscattDirichletTrace.coefficients()))
ysca = np.concatenate((ysca, MTFscattNeumannTrace.coefficients()))

yyext = np.array([])
for ii in xrange(len(rhsSTF)):
    gf = STFsolution.gridFunction(ii)
    yyext = np.concatenate((yyext, gf.coefficients()))


    

# x_mtf_ext = np.array([])
# for ii in xrange(2):
#     gf = MTFsolution.gridFunction(ii)
#     x_mtf_ext = np.concatenate((x_mtf_ext, gf.coefficients()))

# y_mtf_ext = np.array([])
# for ii in [0, 2]:
#     gf = MTFsolution.gridFunction(ii)
#     y_mtf_ext = np.concatenate((y_mtf_ext, gf.coefficients()))
# y_stf_ext = np.array([])
# for ii in [0, 1]:
#     gf = STFsolution.gridFunction(ii)
#     y_stf_ext = np.concatenate((y_stf_ext, gf.coefficients()))


# t0 = time.time()
# xla = la.solve(M, b)
# t1 = time.time()
# print(t1-t0)

# t0 = time.time()
# sM = sp.csc_matrix(M)
# t1 = time.time()
# print(t1-t0)

# t0 = time.time()
# sx = spla.spsolve(sM, b)
# t1 = time.time()
# print(t1-t0)

# t0 = time.time()
# sxx = spla.spsolve(sM, b, use_umfpack=True)
# t1 = time.time()
# print(t1-t0)


# print(np.allclose(x, y)),
# print(np.allclose(M.dot(x), b)),
# print(np.allclose(M.dot(y), b)),

print('\n\nCalderon error: absolute ; relative')
e = 2*A.dot(x) - II.dot(x)
print(np.linalg.norm(e)),
print('\t ; \t'),
print(np.linalg.norm(e) / np.linalg.norm(x))

print('\n MTF bempp')
e = 2*A.dot(y) - II.dot(y)
print(np.linalg.norm(e)),
print('\t ; \t'),
print(np.linalg.norm(e) / np.linalg.norm(y))

print('\n STF bempp')
e = 2*A.dot(yy) - II.dot(yy)
print(np.linalg.norm(e)),
print('\t ; \t'),
print(np.linalg.norm(e) / np.linalg.norm(yy))
        

print('\nMTF bempp ext')
e = 2*A0.dot(yext) - IJ.dot(yext)
print(np.linalg.norm(e)),
print('\t ; \t'),
print(np.linalg.norm(e) / np.linalg.norm(yext))
print('MTF bempp int')
ee = 2*A1.dot(yint) - IJ.dot(yint)
print(np.linalg.norm(ee)),
print('\t ; \t'),
print(np.linalg.norm(ee) / np.linalg.norm(yint))
print('MTF bempp ext-int')
e = (ysca-yint_sign)
print(np.linalg.norm(e))

print('\n STF bempp ext')
e = 2*A0.dot(yyext) - IJ.dot(yyext)
print(np.linalg.norm(e)),
print('\t ; \t'),
print(np.linalg.norm(e) / np.linalg.norm(yyext))
print('STF bempp int')
e = 2*A1.dot(yyext) - IJ.dot(yyext)
print(np.linalg.norm(e)),
print('\t ; \t'),
print(np.linalg.norm(e) / np.linalg.norm(yyext))

print('MTF STF bempp ext')
e = (yext-yyext)
print(np.linalg.norm(e))
e = (yext+yyext)
print(np.linalg.norm(e))
