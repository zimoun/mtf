#!/usr/bin/env python

# This script calculates the field generated by a z-polarised, x-propagating
# plane wave incident on a dielectric sphere.

# Help Python find the bempp module
import sys
sys.path.append("..")

from bempp.lib import *
import numpy as np

from matplotlib import pylab as pl

import scipy.linalg as la
import scipy.sparse as sp
import scipy.sparse.linalg as spla

import time

# Physical Parameters

epsInt = 2.5**2
epsExt = 1
muInt = 1
muExt = 1
wavelengthVacuum = 3.
kVacuum = 2 * np.pi / wavelengthVacuum
kExt = kVacuum * np.sqrt(epsExt * muExt)
kInt = kVacuum * np.sqrt(epsInt * muInt)
rho = (kInt * muExt) / (kExt * muInt)

# Boundary conditions

def evalIncDirichletTrace(point, normal):
    x, y, z = point
    return np.exp( 1j * kExt * (x))

def evalIncNeumannTrace(point, normal):
    x, y, z = point
    nx, ny, nz = normal
#    return -1j * (nx+ny) * kExt * np.exp( 1j * kExt * (x+y))
#    return 1j * nx * kExt * np.exp( 1j * kExt * x)
    return -1j * nx * kExt * np.exp( 1j * kExt * x)


# 
print('==== Create quadrature strategy')

accuracyOptions = createAccuracyOptions()
accuracyOptions.doubleRegular.setRelativeQuadratureOrder(2)
accuracyOptions.doubleSingular.setRelativeQuadratureOrder(1)
quadStrategy = createNumericalQuadratureStrategy(
    "float64", "complex128", accuracyOptions)

# 
print('==== Create assembly context')

assemblyOptions = createAssemblyOptions()
#assemblyOptions.switchToAcaMode(createAcaOptions())
context = createContext(quadStrategy, assemblyOptions)

# 
print('==== Load mesh')
#meshname = "./sphere-simple.msh"
meshname = "./sphere.msh"
#meshname = "./cube.msh"
grid = createGridFactory().importGmshGrid(
    "triangular", meshname)

# 
print('==== Initialize functional spaces')

#space = createPiecewiseConstantScalarSpace(context, grid)
#space = createPiecewiseConstantDualGridScalarSpace(context, grid)

space = createPiecewiseLinearContinuousScalarSpace(context, grid)

#space = createPiecewisePolynomialContinuousScalarSpace(context, grid, 
                                                       # polynomialOrder=1)
#space = createPiecewiseLinearDiscontinuousScalarSpace(context, grid)

# 
print('==== Define the grid functions for the traces of incident field')

incDirichletTrace = createGridFunction(
    context, space, space, evalIncDirichletTrace,
    surfaceNormalDependent=True)
incNeumannTrace = createGridFunction(
    context, space, space, evalIncNeumannTrace,
    surfaceNormalDependent=True)

#
print('==== Construct elementary operators')


V0 = createHelmholtz3dSingleLayerBoundaryOperator(
    context, space, space, space, kExt, "V")
K0 = createHelmholtz3dDoubleLayerBoundaryOperator(
    context, space, space, space, kExt, "K")
K0a = createHelmholtz3dAdjointDoubleLayerBoundaryOperator(
    context, space, space, space, kExt, "K")
W0 = createHelmholtz3dHypersingularBoundaryOperator(
    context, space, space, space, kExt, "W")
V1 = createHelmholtz3dSingleLayerBoundaryOperator(
    context, space, space, space, kInt, "V1")
K1 = createHelmholtz3dDoubleLayerBoundaryOperator(
    context, space, space, space, kInt, "K1")
K1a = createHelmholtz3dAdjointDoubleLayerBoundaryOperator(
    context, space, space, space, kInt, "K1")
W1 = createHelmholtz3dHypersingularBoundaryOperator(
    context, space, space, space, kInt, "W1")

Id = createIdentityOperator(
    context, space, space, space, "Id")
Zd = createNullOperator(
    context, space, space, space, "Zd")

# reorientation normal
ak, bq = -1. , -1.
K0, K0a = ak * K0, bq * K0a

# 
print('==== Form the STF matrix')

STF00 = -K0+K1
STF01 = V0+V1
STF10 = W0+W1
STF11 = K0a-K1a

STF_list = [[STF00, STF01], [STF10, STF11]]

STF = createBlockedBoundaryOperator(
    context, STF_list)

for obj in STF_list:
    for o in obj:
        a = o.weakForm()
a = Id.weakForm()

rhsP = [Id * incNeumannTrace, Id * incDirichletTrace]
rhsSTF = [ (0.5*Id + K1) * incDirichletTrace - V1 * incNeumannTrace,
           +W1 * incDirichletTrace + (-0.5*Id+K1a) * incNeumannTrace]


# 
print('==== Initialize the solver')

STFsolver = createDefaultDirectSolver(STF)

# 
print('==== Solve STF \t'),
print(STF.weakForm().shape)
sys.stdout.flush()

t0 = time.time()
STFsolution = STFsolver.solve(rhsSTF)
t1 = time.time()
print(t1-t0)
print STFsolution.solverMessage()

print('==== end solved... extraction...')

########################################################
########################################################

# STF extraction
# Extract the solution components in the form of grid functions

STFextDirichletTrace = STFsolution.gridFunction(0)
STFextNeumannTrace = STFsolution.gridFunction(1)

exportToGmsh(STFextDirichletTrace, 'STF-dext', 'STF_Dext.pos')
exportToGmsh(STFextNeumannTrace, 'STF-next', 'STF_Next.pos')

STFscattDirichletTrace = STFextDirichletTrace - incDirichletTrace
STFscattNeumannTrace = STFextNeumannTrace - incNeumannTrace

exportToGmsh(STFscattDirichletTrace, 'STF-dsca', 'STF_Dsca.pos')

STFintDirichletTrace = STFextDirichletTrace
STFintNeumannTrace = STFextNeumannTrace 

########################################################
########################################################
